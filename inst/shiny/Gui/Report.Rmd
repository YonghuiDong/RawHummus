---
title: "RawHumms Data Quality Control Report"
date: '`r format(Sys.Date(),  "%d, %B, %Y")`'
output: 
  html_document:
    theme: flatly
    toc: true
    toc_float: true
    number_sections: true
    css: style.css
params:
  msdata: NA
  mynoise: NA
  mypeaks: NA
  myppm: NA
  myrt: NA
editor_options: 
  chunk_output_type: console
---

```{r setup, echo = FALSE, warning = FALSE, message = FALSE}

# get data and clean them
msdata <- params$msdata
mypeaks <- params$mypeaks
mynoise <- params$mynoise
myppm <- params$myppm
myrt <- params$myrt
## remove rows with m/z being NA in mypeaks and rename RT column
mypeaks <- as.data.frame(mypeaks) %>% 
  rename(rt = Expected_RT) %>%
  filter(!is.na(mz))

```

<img src = "logo.png" height = "120" style = "position: absolute; top: 20px; right: 10px;"/>

<br>

# Introduction

Metabolomics studies often comprise complex biological matrices resulting in huge amounts of data. Therefor raw data needs to be inspected before data processing in order to detect any putative error sources, e.g., retention time (RT) or mass accuracy shifts. In particular, proper quality control (QC) checks (e.g., for precision, signal drifts or offsets) are necessary in liquid chromatography mass spectrometry (LCMS) based metabolomics studies to ensure reliable and comparable results within experimental measurements [1-2].

<span style = "color : #FF8300">**RawHummus**</span> is an user-friendly web application for rapid data quality check based on raw QC samples. It generates an HTML report with interactive plots, statistics and detailed illustrations that help users evaluate their data quality and LCMS system performance.

# Data Overview

## TIC plot

`Total Ion Current (TIC)` chromatogram represents the summed ion intensity across each scan in the analysis. **The interactive overlaid TIC plot** can be used for rapid inspection of retention time (RT) and ion intensity fluctuations.

```{r TIC, echo = FALSE, out.width = "100%"}

plotTIC <- ggplot(msdata$TIC) + 
  geom_line(aes(x = rt, y = int, color = filename)) +
  labs(x = "RT (min)", y = "Intensity", color = "File name: ") +
  theme_bw()

ggplotly(plotTIC)

```

## Summed TIC Plot

**Summed TIC plot** is another quick-and-dirty way to overview global ion intensity variations among QC samples. It summed TIC across the entire point (scan) in the analysis. 

```{r sumTIC, echo = FALSE, warning = FALSE, message = FALSE, out.width = "100%"}

sumTIC <- msdata$TIC %>%
  group_by(filename) %>%
  summarise(peakArea = sum(int))

plotSumTIC <- ggplot(sumTIC, aes(x = filename, y = peakArea, group = 1)) +
  geom_bar(stat = "identity", aes(fill = filename), alpha = 0.5) +
  labs(x = "File name", y = "Summed TIC", fill = "File name") +
  theme_bw() +
  theme(axis.text.x = element_blank()) 

ggplotly(plotSumTIC)

```

## QC Correlation Analysis

**Pearson correlation** is  used to quantify the metabolic profile similarity among QC samples. Pearson correlation coefficient closer to <span style = "color: #ff8080">**1**</span> indicate high similarity and therefore good LCMS system stability.

> **Note that** as the number of mass features may vary among QC samples, TIC at each scan is used to calculate Pearson correlation coefficient.
In cases where total number of scans are different among QC samples (which is usually due to the system virations at the end of the run), samples are automatically trimmed before calculating Pearson correlation coefficient.

```{r corTIC, echo = FALSE, warning = FALSE, message = FALSE, out.width = "100%"}

## if scan number is the same, corTIC is dataframe, otherwise it is list
corTIC <- msdata$TIC %>%
  select(int, filename) %>%
  unstack()

## calculate correlation.
if(is.data.frame(corTIC)){
  kableExtra::kbl(round(cor(corTIC), 2), escape = FALSE, caption = "Table 1: TIC correlation")  %>%
  kableExtra::kable_classic("hover", full_width = TRUE)
} else {
  ## get the minimum scan number
  minScan <- min(map_df(corTIC, length))
  
  ## trim scans
  corTIC2 <- map_df(corTIC, `[`, 1: minScan)
  
  ## correlation table
  kableExtra::kbl(round(cor(corTIC2), 2),
                  escape = FALSE, 
                  caption = paste0("Table 1: TIC correlation (Trimmed sample with total scan number of ", minScan, ")"))  %>%
  kableExtra::kable_classic("hover", full_width = TRUE)
  
}

```

# MS1

## Auto Peaks Evaluation

In order to more accurately monitor the variations in mass accuracy, RT consistency and ion intensity stability, <span style = "color : #FF8300">**RawHummus**</span> automatically selects **6** peaks across the entire RT range, and use them to evaluate LCMS system.

Below are the Extracted ion chromatogram (EIC) of the 6 selected ions. You can interactively view, inspect and compare them among QC samples.

```{r MS1Plot, echo = FALSE, out.width = "100%"}

# get lists of peaks for evaluation
MS1Filter <- msdata$MS1 %>%
  filter(int > mynoise) ## filter according user defined noise

# get min and max RT of madata
minRT <- min(MS1Filter$rt)
maxRT <- max(MS1Filter$rt)

topPeaks <- MS1Filter %>% 
  mutate(bins = ntile(rt, 6)) %>%
  group_by(bins) %>%
  slice_max(int, n = 1) %>%
  ungroup() %>%
  select(rt, mz)

# search in raw data
autoTarget <- vector(mode = "list", length = dim(topPeaks)[1])

for (i in 1:dim(topPeaks)[1]){
  autoTarget[[i]] <- MS1Filter %>%
    filter(between(mz, pmppm(topPeaks$mz[i], myppm)[1], pmppm(topPeaks$mz[i], myppm)[2]) & 
             between(rt, max(topPeaks$rt[i] - myrt, minRT), min(topPeaks$rt[i] + myrt, maxRT)))
  names(autoTarget)[i] <- paste0("RT: ", round(topPeaks$rt[i], 2), " mz: ", round(topPeaks$mz[i], 3))
  
}

# unlist
autoTarget <- dplyr::bind_rows(autoTarget, .id = "id")

# plot
if (nrow(autoTarget) > 0) {
    aPlot <- ggplot(autoTarget) + 
      geom_line(aes(x = rt, y = int, color = filename)) +
      facet_wrap(~ id, scales = "free_y", ncol = 2) +
      labs(x = "RT (min)", y = "Intensity", color = "File name: ") +
      theme_bw()
    ggplotly(aPlot)
    } else {
      print("Peasks of interests are not found")
    }

```

<span style = "color: #FF8300">**RawHummus**</span> performs a simple statistics to make the comparison simple. The table below summarized the comparison result, in which maximum RT difference, mass difference and ion intensity difference are given. Smaller 

`Max RT Diff (min)`: is the maximum retention time variation (in min unit). Small value indicates a good retention time consistency. If the maximum retention time variation is over <span style = "color: #ff8080">**1 min**</span>, the value will be highlight in <span style = "color: #ff8080">**red**</span> in Table 1. 

`Max Mass Diff (ppm)`: is the maximum mass variation (in ppm unit). Small values indicate good mass accuracy. If the maximum mass variation is over <span style = "color: #ff8080">**5 ppm**</span>, the value will be highlight in <span style = "color: #ff8080">**red**</span> in Table 1.

`Max Intensity Ratio`: is the maximum ion intensity variation. The value closer to 1 suggests that the ion intensity is stable. If the maximum intensity ratio is over <span style = "color: #ff8080">**3**</span>, the value will be highlight in <span style = "color: #ff8080">**red**</span> in Table 1.

```{r MS1Table, echo = FALSE, out.width = "100%"}

if (nrow(autoTarget) > 0) {
 autoTargetTable <- autoTarget %>%
  group_by(id, filename) %>%
  slice_max(int) %>%
  group_by(id) %>%
  mutate("Max RT Diff (min)" = round(max(rt) - min(rt), 2),
         "Max Mass Diff (ppm)" = round((max(mz) - min(mz))/min(mz) * 10^6, 2),
         "Max Intensity Ratio" = round(max(int) / min(int), 2)) %>%
  mutate(Peak = id) %>%
  ungroup() %>%
  select(Peak, "Max RT Diff (min)", "Max Mass Diff (ppm)", "Max Intensity Ratio") %>%
  distinct_all() %>% 
  mutate("Max RT Diff (min)" = kableExtra::cell_spec(`Max RT Diff (min)`,
                                                     background = ifelse(`Max RT Diff (min)` > 1, "#ff8080", "#FFFFFF")),
         "Max Mass Diff (ppm)" = kableExtra::cell_spec(`Max Mass Diff (ppm)`, 
                                                       background = ifelse(`Max Mass Diff (ppm)` > 5, "#ff8080", "#FFFFFF")),
         "Max Intensity Ratio" = kableExtra::cell_spec(`Max Intensity Ratio`, 
                                                       background = ifelse(`Max Intensity Ratio` > 3, "#ff8080", "#FFFFFF")))
 
 ## use kableExtra instead of DT
 kableExtra::kbl(autoTargetTable, escape = FALSE, caption = "Table 2: Summary of auto-selected peaks") %>%
  kableExtra::kable_classic("hover", full_width = TRUE)

} else {
  print("Peasks of interests are not found")
}

```

## User defined peaks

Additionally, users could add their peaks of interests for inspection and comparison. If these peaks are defined in <span style = "color: #FF8300">**RawHummus**</span> and are found in the data. Similar plots and a data summary table will be given below. Otherwise, this section will be left blank.

```{r userMS1Plot, echo = FALSE, out.width = "100%"}

if(!all(is.na(mypeaks))) {
  
  # search according to mz and RT with tolerances
  getTarget <- vector(mode = "list", length = dim(mypeaks)[1])
  
  for (i in 1:dim(mypeaks)[1]){
    getTarget[[i]] <- MS1Filter %>%
    filter(between(mz, pmppm(mypeaks$mz[i], myppm)[1], pmppm(mypeaks$mz[i], myppm)[2]) & 
             between(rt, max(mypeaks$rt[i] - myrt, minRT, na.rm = TRUE), min(mypeaks$rt[i] + myrt, maxRT, na.rm = TRUE)))
    names(getTarget)[i] <- paste0(" RT: ", round(mypeaks$rt[i], 2), " mz: ", round(mypeaks$mz[i], 3))
  }
  
  # unlist
  myTarget <- dplyr::bind_rows(getTarget, .id = "id")
  
  # plot
  if (nrow(myTarget) > 0) {
    uPlot <- ggplot(myTarget) + 
      geom_line(aes(x = rt, y = int, color = filename)) +
      facet_wrap(~ id, scales = "free_y", ncol = 2) +
      labs(x = "RT (min)", y = "Intensity", color = "File name: ") +
      theme_bw()
    ggplotly(uPlot)
    }
  
} else {
  myTarget <- NULL
  print("User defined peaks are not found")
}

```


```{r userMS1Table, echo = FALSE, out.width = "100%"}

if (!is.null(myTarget)) {
 myTargetTable <- myTarget %>%
  group_by(id, filename) %>%
  slice_max(int) %>%
  group_by(id) %>%
  mutate("Max RT Diff (min)" = round(max(rt) - min(rt), 2),
         "Max Mass Diff (ppm)" = round((max(mz) - min(mz))/min(mz) * 10^6, 2),
         "Max Intensity Ratio" = round(max(int) / min(int), 2)) %>%
  mutate(Peak = id) %>%
  ungroup() %>%
  select(Peak, "Max RT Diff (min)", "Max Mass Diff (ppm)", "Max Intensity Ratio") %>%
  distinct_all() %>%
  mutate("Max RT Diff (min)" = kableExtra::cell_spec(`Max RT Diff (min)`,
                                                     background = ifelse(`Max RT Diff (min)` > 1, "#ff8080", "#FFFFFF")),
         "Max Mass Diff (ppm)" = kableExtra::cell_spec(`Max Mass Diff (ppm)`, 
                                                       background = ifelse(`Max Mass Diff (ppm)` > 5, "#ff8080", "#FFFFFF")),
         "Max Intensity Ratio" = kableExtra::cell_spec(`Max Intensity Ratio`, 
                                                       background = ifelse(`Max Intensity Ratio` > 3, "#ff8080", "#FFFFFF")))

## use kableExtra instead of DT 
 kableExtra::kbl(myTargetTable, escape = FALSE, caption = "Table 3: Summary of user-defined peaks") %>%
  kableExtra::kable_classic("hover", full_width = TRUE)
 
 }

```

# MS2

MS2 is another information for inspection. If 

## Number of MS2

```{r MS2, echo = FALSE}

if(nrow(msdata$MS2) == 0){
  getMS2 <- NULL
  MS2_mz <- NULL
  MS2_RT <- NULL
} else {
  getMS2 <- msdata$MS2 %>% 
    group_by(filename) %>%
    distinct(rt, premz) %>%
    summarise("MS2 Events" = n())
  
  MS2unique <- msdata$MS2 %>%
  distinct(rt, premz, voltage, filename)
  
  ## plot precursor ion across mz range
  MS2_mz <- ggplot(MS2unique, aes(premz)) +
    geom_density(aes(fill = filename), alpha = 0.3) +
    facet_wrap(~ filename, scales = "free_y", ncol = 2) +
    labs(x = "Mass Range", y = "Density", fill = "File name") +
    theme_bw() +
    theme(legend.position = "none")
  
  ## plot precursor ions across RT range
  MS2_RT <- ggplot(MS2unique, aes(rt, fill = filename)) +
    geom_density(alpha = 0.3) +
    facet_wrap(~ filename, scales = "free_y", ncol = 2) +
    labs(x = "RT (min)", y = "Density", fill = "File name") +
    theme_bw() +
    theme(legend.position = "none")
}

```

```{r MS2Table, echo = FALSE, out.width = "100%"}

## use kableExtra instead of DT 
if(!is.null(getMS2)){
  kableExtra::kbl(getMS2, escape = FALSE, caption = "Table 4: Summary of MS2 events") %>%
    kableExtra::kable_classic("hover", full_width = TRUE)
} else {
  print("not exist")
}

```
 
## Precursor Distribution accross mass 

```{r MS2MZ, echo = FALSE, out.width = "100%"}

if(!is.null(MS2_mz)){
   MS2_mz 
} else {
  print("not exist")
  
}

```

## Precursor Distribution accross RT

```{r MS2RT, echo = FALSE, out.width = "100%"}

if(!is.null(MS2_RT)){
   MS2_RT
} else {
  print("not exist")
}

```

# Reference

[1] Scalbert, A., Brennan, L., Fiehn, O., Hankemeier, T., Kristal, B.S., van Ommen, B., Pujos-Guillot, E., Verheij, E., Wishart, D. and Wopereis, S., 2009. Mass-spectrometry-based metabolomics: limitations and recommendations for future progress with particular focus on nutrition research. Metabolomics, 5(4), pp.435-458.

[2] Begou, O., Gika, H.G., Theodoridis, G.A. and Wilson, I.D., 2018. Quality Control and Validation Issues in LC-MS Metabolomics. Methods in molecular biology (Clifton, NJ), 1738, pp.15-26.



